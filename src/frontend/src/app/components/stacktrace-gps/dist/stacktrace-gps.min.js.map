{"version":3,"sources":["stackframe.js","bundle.js","stacktrace-gps.js"],"names":["root","factory","define","amd","exports","module","StackFrame","this","_isNumber","n","isNaN","parseFloat","isFinite","functionName","args","fileName","lineNumber","columnNumber","source","undefined","setFunctionName","setArgs","setFileName","setLineNumber","setColumnNumber","setSource","prototype","getFunctionName","v","String","getArgs","Object","toString","call","TypeError","getFileName","getLineNumber","Number","getColumnNumber","getSource","join","SourceMap","modules","__webpack_require__","moduleId","installedModules","id","loaded","m","c","p","SourceMapConsumer","aSourceMap","sourceMap","JSON","parse","replace","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","version","util","getArg","sources","names","sourceRoot","sourcesContent","mappings","file","_version","Error","map","normalize","isAbsolute","relative","_names","ArraySet","fromArray","_sources","_mappings","Mapping","generatedLine","generatedColumn","originalLine","originalColumn","name","lastOffset","line","column","_sections","s","url","offset","offsetLine","offsetColumn","generatedOffset","consumer","binarySearch","base64VLQ","quickSort","fromSourceMap","__generatedMappings","defineProperty","get","_parseMappings","__originalMappings","_charIsMappingSeparator","aStr","index","charAt","aSourceRoot","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","eachMapping","aCallback","aContext","aOrder","context","order","_generatedMappings","_originalMappings","mapping","at","forEach","allGeneratedPositionsFor","aArgs","needle","has","indexOf","_findMapping","compareByOriginalPositions","push","lastColumn","create","smc","toArray","_sourceRoot","_generateSourcesContent","_file","generatedMappings","slice","destGeneratedMappings","destOriginalMappings","i","length","srcMapping","destMapping","str","segment","end","value","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","temp","originalMappings","decode","rest","compareByGeneratedPositionsDeflated","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","originalPositionFor","hasContentsOfAllSources","size","some","sc","sourceContentFor","aSource","nullOnMissing","urlParse","fileUriAbsPath","scheme","path","generatedPositionFor","constructor","j","sectionIndex","section","cmp","bias","every","content","generatedPosition","ret","sectionMappings","add","adjustedMapping","aName","aDefaultValue","arguments","aUrl","match","urlRegexp","auth","host","port","urlGenerate","aParsedUrl","aPath","part","parts","split","up","splice","aRoot","aPathUrl","aRootUrl","dataUrlRegexp","joined","level","lastIndexOf","Array","substr","toSetString","fromSetString","mappingA","mappingB","onlyCompareOriginal","onlyCompareGenerated","strcmp","aStr1","aStr2","compareByGeneratedPositionsInflated","recursiveSearch","aLow","aHigh","aHaystack","aCompare","mid","Math","floor","_array","_set","aArray","aAllowDuplicates","set","len","getOwnPropertyNames","sStr","isDuplicate","hasOwnProperty","idx","aIdx","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","encode","digit","encoded","vlq","aIndex","aOutParam","continuation","strLen","result","shift","charCodeAt","intToCharMap","number","charCode","bigA","bigZ","littleA","littleZ","zero","nine","plus","slash","littleOffset","numberOffset","swap","ary","x","y","randomIntInRange","low","high","round","random","doQuickSort","comparator","r","pivotIndex","pivot","q","require","StackTraceGPS","_xdr","Promise","resolve","reject","req","XMLHttpRequest","open","onerror","onreadystatechange","readyState","status","responseText","send","_findFunctionName","commentPos","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","lines","code","maxLines","min","exec","_ensureSupportedEnvironment","_ensureStackFrameIsLegit","stackframe","_findSourceMappingURL","_extractLocationInfoFromSourceMap","rawSourceMap","sourceCache","mapConsumer","loc","mappedSource","opts","ajax","_get","location","isDataUrl","offline","supportedEncoding","sourceMapStart","encodedSource","window","atob","xhrPromise","method","then","bind","pinpoint","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","sourceMappingURL","substring"],"mappings":"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","file":"stacktrace-gps.min.js","sourcesContent":["(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function () {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n        if (functionName !== undefined) {\n            this.setFunctionName(functionName);\n        }\n        if (args !== undefined) {\n            this.setArgs(args);\n        }\n        if (fileName !== undefined) {\n            this.setFileName(fileName);\n        }\n        if (lineNumber !== undefined) {\n            this.setLineNumber(lineNumber);\n        }\n        if (columnNumber !== undefined) {\n            this.setColumnNumber(columnNumber);\n        }\n        if (source !== undefined) {\n            this.setSource(source);\n        }\n    }\n\n    StackFrame.prototype = {\n        getFunctionName: function () {\n            return this.functionName;\n        },\n        setFunctionName: function (v) {\n            this.functionName = String(v);\n        },\n\n        getArgs: function () {\n            return this.args;\n        },\n        setArgs: function (v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        // NOTE: Property name may be misleading as it includes the path,\n        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n        getFileName: function () {\n            return this.fileName;\n        },\n        setFileName: function (v) {\n            this.fileName = String(v);\n        },\n\n        getLineNumber: function () {\n            return this.lineNumber;\n        },\n        setLineNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Line Number must be a Number');\n            }\n            this.lineNumber = Number(v);\n        },\n\n        getColumnNumber: function () {\n            return this.columnNumber;\n        },\n        setColumnNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Column Number must be a Number');\n            }\n            this.columnNumber = Number(v);\n        },\n\n        getSource: function () {\n            return this.source;\n        },\n        setSource: function (v) {\n            this.source = String(v);\n        },\n\n        toString: function() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    return StackFrame;\n}));\n","var SourceMap =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t{\n\t  var util = __webpack_require__(1);\n\t  var binarySearch = __webpack_require__(2);\n\t  var ArraySet = __webpack_require__(3).ArraySet;\n\t  var base64VLQ = __webpack_require__(4);\n\t  var quickSort = __webpack_require__(6).quickSort;\n\n\t  function SourceMapConsumer(aSourceMap) {\n\t    var sourceMap = aSourceMap;\n\t    if (typeof aSourceMap === 'string') {\n\t      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t    }\n\n\t    return sourceMap.sections != null\n\t      ? new IndexedSourceMapConsumer(sourceMap)\n\t      : new BasicSourceMapConsumer(sourceMap);\n\t  }\n\n\t  SourceMapConsumer.fromSourceMap = function(aSourceMap) {\n\t    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n\t  }\n\n\t  /**\n\t   * The version of the source mapping spec that we are consuming.\n\t   */\n\t  SourceMapConsumer.prototype._version = 3;\n\n\t  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t  // are lazily instantiated, accessed via the `_generatedMappings` and\n\t  // `_originalMappings` getters respectively, and we only parse the mappings\n\t  // and create these arrays once queried for a source location. We jump through\n\t  // these hoops because there can be many thousands of mappings, and parsing\n\t  // them is expensive, so we only want to do it if we must.\n\t  //\n\t  // Each object in the arrays is of the form:\n\t  //\n\t  //     {\n\t  //       generatedLine: The line number in the generated code,\n\t  //       generatedColumn: The column number in the generated code,\n\t  //       source: The path to the original source file that generated this\n\t  //               chunk of code,\n\t  //       originalLine: The line number in the original source that\n\t  //                     corresponds to this chunk of generated code,\n\t  //       originalColumn: The column number in the original source that\n\t  //                       corresponds to this chunk of generated code,\n\t  //       name: The name of the original symbol which generated this chunk of\n\t  //             code.\n\t  //     }\n\t  //\n\t  // All properties except for `generatedLine` and `generatedColumn` can be\n\t  // `null`.\n\t  //\n\t  // `_generatedMappings` is ordered by the generated positions.\n\t  //\n\t  // `_originalMappings` is ordered by the original positions.\n\n\t  SourceMapConsumer.prototype.__generatedMappings = null;\n\t  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t    get: function () {\n\t      if (!this.__generatedMappings) {\n\t        this._parseMappings(this._mappings, this.sourceRoot);\n\t      }\n\n\t      return this.__generatedMappings;\n\t    }\n\t  });\n\n\t  SourceMapConsumer.prototype.__originalMappings = null;\n\t  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t    get: function () {\n\t      if (!this.__originalMappings) {\n\t        this._parseMappings(this._mappings, this.sourceRoot);\n\t      }\n\n\t      return this.__originalMappings;\n\t    }\n\t  });\n\n\t  SourceMapConsumer.prototype._charIsMappingSeparator =\n\t    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t      var c = aStr.charAt(index);\n\t      return c === \";\" || c === \",\";\n\t    };\n\n\t  /**\n\t   * Parse the mappings in a string in to a data structure which we can easily\n\t   * query (the ordered arrays in the `this.__generatedMappings` and\n\t   * `this.__originalMappings` properties).\n\t   */\n\t  SourceMapConsumer.prototype._parseMappings =\n\t    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t      throw new Error(\"Subclasses must implement _parseMappings\");\n\t    };\n\n\t  SourceMapConsumer.GENERATED_ORDER = 1;\n\t  SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n\t  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\t  SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n\t  /**\n\t   * Iterate over each mapping between an original source/line/column and a\n\t   * generated line/column in this source map.\n\t   *\n\t   * @param Function aCallback\n\t   *        The function that is called with each mapping.\n\t   * @param Object aContext\n\t   *        Optional. If specified, this object will be the value of `this` every\n\t   *        time that `aCallback` is called.\n\t   * @param aOrder\n\t   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t   *        iterate over the mappings sorted by the generated file's line/column\n\t   *        order or the original's source/line/column order, respectively. Defaults to\n\t   *        `SourceMapConsumer.GENERATED_ORDER`.\n\t   */\n\t  SourceMapConsumer.prototype.eachMapping =\n\t    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t      var context = aContext || null;\n\t      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n\t      var mappings;\n\t      switch (order) {\n\t      case SourceMapConsumer.GENERATED_ORDER:\n\t        mappings = this._generatedMappings;\n\t        break;\n\t      case SourceMapConsumer.ORIGINAL_ORDER:\n\t        mappings = this._originalMappings;\n\t        break;\n\t      default:\n\t        throw new Error(\"Unknown order of iteration.\");\n\t      }\n\n\t      var sourceRoot = this.sourceRoot;\n\t      mappings.map(function (mapping) {\n\t        var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t        if (source != null && sourceRoot != null) {\n\t          source = util.join(sourceRoot, source);\n\t        }\n\t        return {\n\t          source: source,\n\t          generatedLine: mapping.generatedLine,\n\t          generatedColumn: mapping.generatedColumn,\n\t          originalLine: mapping.originalLine,\n\t          originalColumn: mapping.originalColumn,\n\t          name: mapping.name === null ? null : this._names.at(mapping.name)\n\t        };\n\t      }, this).forEach(aCallback, context);\n\t    };\n\n\t  /**\n\t   * Returns all generated line and column information for the original source,\n\t   * line, and column provided. If no column is provided, returns all mappings\n\t   * corresponding to a either the line we are searching for or the next\n\t   * closest line that has any mappings. Otherwise, returns all mappings\n\t   * corresponding to the given line and either the column we are searching for\n\t   * or the next closest column that has any offsets.\n\t   *\n\t   * The only argument is an object with the following properties:\n\t   *\n\t   *   - source: The filename of the original source.\n\t   *   - line: The line number in the original source.\n\t   *   - column: Optional. the column number in the original source.\n\t   *\n\t   * and an array of objects is returned, each with the following properties:\n\t   *\n\t   *   - line: The line number in the generated source, or null.\n\t   *   - column: The column number in the generated source, or null.\n\t   */\n\t  SourceMapConsumer.prototype.allGeneratedPositionsFor =\n\t    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n\t      var line = util.getArg(aArgs, 'line');\n\n\t      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n\t      // returns the index of the closest mapping less than the needle. By\n\t      // setting needle.originalColumn to 0, we thus find the last mapping for\n\t      // the given line, provided such a mapping exists.\n\t      var needle = {\n\t        source: util.getArg(aArgs, 'source'),\n\t        originalLine: line,\n\t        originalColumn: util.getArg(aArgs, 'column', 0)\n\t      };\n\n\t      if (this.sourceRoot != null) {\n\t        needle.source = util.relative(this.sourceRoot, needle.source);\n\t      }\n\t      if (!this._sources.has(needle.source)) {\n\t        return [];\n\t      }\n\t      needle.source = this._sources.indexOf(needle.source);\n\n\t      var mappings = [];\n\n\t      var index = this._findMapping(needle,\n\t                                    this._originalMappings,\n\t                                    \"originalLine\",\n\t                                    \"originalColumn\",\n\t                                    util.compareByOriginalPositions,\n\t                                    binarySearch.LEAST_UPPER_BOUND);\n\t      if (index >= 0) {\n\t        var mapping = this._originalMappings[index];\n\n\t        if (aArgs.column === undefined) {\n\t          var originalLine = mapping.originalLine;\n\n\t          // Iterate until either we run out of mappings, or we run into\n\t          // a mapping for a different line than the one we found. Since\n\t          // mappings are sorted, this is guaranteed to find all mappings for\n\t          // the line we found.\n\t          while (mapping && mapping.originalLine === originalLine) {\n\t            mappings.push({\n\t              line: util.getArg(mapping, 'generatedLine', null),\n\t              column: util.getArg(mapping, 'generatedColumn', null),\n\t              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t            });\n\n\t            mapping = this._originalMappings[++index];\n\t          }\n\t        } else {\n\t          var originalColumn = mapping.originalColumn;\n\n\t          // Iterate until either we run out of mappings, or we run into\n\t          // a mapping for a different line than the one we were searching for.\n\t          // Since mappings are sorted, this is guaranteed to find all mappings for\n\t          // the line we are searching for.\n\t          while (mapping &&\n\t                 mapping.originalLine === line &&\n\t                 mapping.originalColumn == originalColumn) {\n\t            mappings.push({\n\t              line: util.getArg(mapping, 'generatedLine', null),\n\t              column: util.getArg(mapping, 'generatedColumn', null),\n\t              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t            });\n\n\t            mapping = this._originalMappings[++index];\n\t          }\n\t        }\n\t      }\n\n\t      return mappings;\n\t    };\n\n\t  exports.SourceMapConsumer = SourceMapConsumer;\n\n\t  /**\n\t   * A BasicSourceMapConsumer instance represents a parsed source map which we can\n\t   * query for information about the original file positions by giving it a file\n\t   * position in the generated source.\n\t   *\n\t   * The only parameter is the raw source map (either as a JSON string, or\n\t   * already parsed to an object). According to the spec, source maps have the\n\t   * following attributes:\n\t   *\n\t   *   - version: Which version of the source map spec this map is following.\n\t   *   - sources: An array of URLs to the original source files.\n\t   *   - names: An array of identifiers which can be referrenced by individual mappings.\n\t   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n\t   *   - sourcesContent: Optional. An array of contents of the original source files.\n\t   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n\t   *   - file: Optional. The generated file this source map is associated with.\n\t   *\n\t   * Here is an example source map, taken from the source map spec[0]:\n\t   *\n\t   *     {\n\t   *       version : 3,\n\t   *       file: \"out.js\",\n\t   *       sourceRoot : \"\",\n\t   *       sources: [\"foo.js\", \"bar.js\"],\n\t   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t   *       mappings: \"AA,AB;;ABCDE;\"\n\t   *     }\n\t   *\n\t   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n\t   */\n\t  function BasicSourceMapConsumer(aSourceMap) {\n\t    var sourceMap = aSourceMap;\n\t    if (typeof aSourceMap === 'string') {\n\t      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t    }\n\n\t    var version = util.getArg(sourceMap, 'version');\n\t    var sources = util.getArg(sourceMap, 'sources');\n\t    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n\t    // requires the array) to play nice here.\n\t    var names = util.getArg(sourceMap, 'names', []);\n\t    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n\t    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n\t    var mappings = util.getArg(sourceMap, 'mappings');\n\t    var file = util.getArg(sourceMap, 'file', null);\n\n\t    // Once again, Sass deviates from the spec and supplies the version as a\n\t    // string rather than a number, so we use loose equality checking here.\n\t    if (version != this._version) {\n\t      throw new Error('Unsupported version: ' + version);\n\t    }\n\n\t    sources = sources\n\t      // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t      // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n\t      // See bugzil.la/1090768.\n\t      .map(util.normalize)\n\t      // Always ensure that absolute sources are internally stored relative to\n\t      // the source root, if the source root is absolute. Not doing this would\n\t      // be particularly problematic when the source root is a prefix of the\n\t      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n\t      .map(function (source) {\n\t        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n\t          ? util.relative(sourceRoot, source)\n\t          : source;\n\t      });\n\n\t    // Pass `true` below to allow duplicate names and sources. While source maps\n\t    // are intended to be compressed and deduplicated, the TypeScript compiler\n\t    // sometimes generates source maps with duplicates in them. See Github issue\n\t    // #72 and bugzil.la/889492.\n\t    this._names = ArraySet.fromArray(names, true);\n\t    this._sources = ArraySet.fromArray(sources, true);\n\n\t    this.sourceRoot = sourceRoot;\n\t    this.sourcesContent = sourcesContent;\n\t    this._mappings = mappings;\n\t    this.file = file;\n\t  }\n\n\t  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\t  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n\t  /**\n\t   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n\t   *\n\t   * @param SourceMapGenerator aSourceMap\n\t   *        The source map that will be consumed.\n\t   * @returns BasicSourceMapConsumer\n\t   */\n\t  BasicSourceMapConsumer.fromSourceMap =\n\t    function SourceMapConsumer_fromSourceMap(aSourceMap) {\n\t      var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n\t      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n\t      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n\t      smc.sourceRoot = aSourceMap._sourceRoot;\n\t      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n\t                                                              smc.sourceRoot);\n\t      smc.file = aSourceMap._file;\n\n\t      // Because we are modifying the entries (by converting string sources and\n\t      // names to indices into the sources and names ArraySets), we have to make\n\t      // a copy of the entry or else bad things happen. Shared mutable state\n\t      // strikes again! See github issue #191.\n\n\t      var generatedMappings = aSourceMap._mappings.toArray().slice();\n\t      var destGeneratedMappings = smc.__generatedMappings = [];\n\t      var destOriginalMappings = smc.__originalMappings = [];\n\n\t      for (var i = 0, length = generatedMappings.length; i < length; i++) {\n\t        var srcMapping = generatedMappings[i];\n\t        var destMapping = new Mapping;\n\t        destMapping.generatedLine = srcMapping.generatedLine;\n\t        destMapping.generatedColumn = srcMapping.generatedColumn;\n\n\t        if (srcMapping.source) {\n\t          destMapping.source = sources.indexOf(srcMapping.source);\n\t          destMapping.originalLine = srcMapping.originalLine;\n\t          destMapping.originalColumn = srcMapping.originalColumn;\n\n\t          if (srcMapping.name) {\n\t            destMapping.name = names.indexOf(srcMapping.name);\n\t          }\n\n\t          destOriginalMappings.push(destMapping);\n\t        }\n\n\t        destGeneratedMappings.push(destMapping);\n\t      }\n\n\t      quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n\t      return smc;\n\t    };\n\n\t  /**\n\t   * The version of the source mapping spec that we are consuming.\n\t   */\n\t  BasicSourceMapConsumer.prototype._version = 3;\n\n\t  /**\n\t   * The list of original sources.\n\t   */\n\t  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n\t    get: function () {\n\t      return this._sources.toArray().map(function (s) {\n\t        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n\t      }, this);\n\t    }\n\t  });\n\n\t  /**\n\t   * Provide the JIT with a nice shape / hidden class.\n\t   */\n\t  function Mapping() {\n\t    this.generatedLine = 0;\n\t    this.generatedColumn = 0;\n\t    this.source = null;\n\t    this.originalLine = null;\n\t    this.originalColumn = null;\n\t    this.name = null;\n\t  }\n\n\t  /**\n\t   * Parse the mappings in a string in to a data structure which we can easily\n\t   * query (the ordered arrays in the `this.__generatedMappings` and\n\t   * `this.__originalMappings` properties).\n\t   */\n\t  BasicSourceMapConsumer.prototype._parseMappings =\n\t    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t      var generatedLine = 1;\n\t      var previousGeneratedColumn = 0;\n\t      var previousOriginalLine = 0;\n\t      var previousOriginalColumn = 0;\n\t      var previousSource = 0;\n\t      var previousName = 0;\n\t      var length = aStr.length;\n\t      var index = 0;\n\t      var cachedSegments = {};\n\t      var temp = {};\n\t      var originalMappings = [];\n\t      var generatedMappings = [];\n\t      var mapping, str, segment, end, value;\n\n\t      while (index < length) {\n\t        if (aStr.charAt(index) === ';') {\n\t          generatedLine++;\n\t          index++;\n\t          previousGeneratedColumn = 0;\n\t        }\n\t        else if (aStr.charAt(index) === ',') {\n\t          index++;\n\t        }\n\t        else {\n\t          mapping = new Mapping();\n\t          mapping.generatedLine = generatedLine;\n\n\t          // Because each offset is encoded relative to the previous one,\n\t          // many segments often have the same encoding. We can exploit this\n\t          // fact by caching the parsed variable length fields of each segment,\n\t          // allowing us to avoid a second parse if we encounter the same\n\t          // segment again.\n\t          for (end = index; end < length; end++) {\n\t            if (this._charIsMappingSeparator(aStr, end)) {\n\t              break;\n\t            }\n\t          }\n\t          str = aStr.slice(index, end);\n\n\t          segment = cachedSegments[str];\n\t          if (segment) {\n\t            index += str.length;\n\t          } else {\n\t            segment = [];\n\t            while (index < end) {\n\t              base64VLQ.decode(aStr, index, temp);\n\t              value = temp.value;\n\t              index = temp.rest;\n\t              segment.push(value);\n\t            }\n\n\t            if (segment.length === 2) {\n\t              throw new Error('Found a source, but no line and column');\n\t            }\n\n\t            if (segment.length === 3) {\n\t              throw new Error('Found a source and line, but no column');\n\t            }\n\n\t            cachedSegments[str] = segment;\n\t          }\n\n\t          // Generated column.\n\t          mapping.generatedColumn = previousGeneratedColumn + segment[0];\n\t          previousGeneratedColumn = mapping.generatedColumn;\n\n\t          if (segment.length > 1) {\n\t            // Original source.\n\t            mapping.source = previousSource + segment[1];\n\t            previousSource += segment[1];\n\n\t            // Original line.\n\t            mapping.originalLine = previousOriginalLine + segment[2];\n\t            previousOriginalLine = mapping.originalLine;\n\t            // Lines are stored 0-based\n\t            mapping.originalLine += 1;\n\n\t            // Original column.\n\t            mapping.originalColumn = previousOriginalColumn + segment[3];\n\t            previousOriginalColumn = mapping.originalColumn;\n\n\t            if (segment.length > 4) {\n\t              // Original name.\n\t              mapping.name = previousName + segment[4];\n\t              previousName += segment[4];\n\t            }\n\t          }\n\n\t          generatedMappings.push(mapping);\n\t          if (typeof mapping.originalLine === 'number') {\n\t            originalMappings.push(mapping);\n\t          }\n\t        }\n\t      }\n\n\t      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t      this.__generatedMappings = generatedMappings;\n\n\t      quickSort(originalMappings, util.compareByOriginalPositions);\n\t      this.__originalMappings = originalMappings;\n\t    };\n\n\t  /**\n\t   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n\t   * we are searching for in the given \"haystack\" of mappings.\n\t   */\n\t  BasicSourceMapConsumer.prototype._findMapping =\n\t    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n\t                                           aColumnName, aComparator, aBias) {\n\t      // To return the position we are searching for, we must first find the\n\t      // mapping for the given position and then return the opposite position it\n\t      // points to. Because the mappings are sorted, we can use binary search to\n\t      // find the best mapping.\n\n\t      if (aNeedle[aLineName] <= 0) {\n\t        throw new TypeError('Line must be greater than or equal to 1, got '\n\t                            + aNeedle[aLineName]);\n\t      }\n\t      if (aNeedle[aColumnName] < 0) {\n\t        throw new TypeError('Column must be greater than or equal to 0, got '\n\t                            + aNeedle[aColumnName]);\n\t      }\n\n\t      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n\t    };\n\n\t  /**\n\t   * Compute the last column for each generated mapping. The last column is\n\t   * inclusive.\n\t   */\n\t  BasicSourceMapConsumer.prototype.computeColumnSpans =\n\t    function SourceMapConsumer_computeColumnSpans() {\n\t      for (var index = 0; index < this._generatedMappings.length; ++index) {\n\t        var mapping = this._generatedMappings[index];\n\n\t        // Mappings do not contain a field for the last generated columnt. We\n\t        // can come up with an optimistic estimate, however, by assuming that\n\t        // mappings are contiguous (i.e. given two consecutive mappings, the\n\t        // first mapping ends where the second one starts).\n\t        if (index + 1 < this._generatedMappings.length) {\n\t          var nextMapping = this._generatedMappings[index + 1];\n\n\t          if (mapping.generatedLine === nextMapping.generatedLine) {\n\t            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n\t            continue;\n\t          }\n\t        }\n\n\t        // The last mapping for each line spans the entire line.\n\t        mapping.lastGeneratedColumn = Infinity;\n\t      }\n\t    };\n\n\t  /**\n\t   * Returns the original source, line, and column information for the generated\n\t   * source's line and column positions provided. The only argument is an object\n\t   * with the following properties:\n\t   *\n\t   *   - line: The line number in the generated source.\n\t   *   - column: The column number in the generated source.\n\t   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t   *     closest element that is smaller than or greater than the one we are\n\t   *     searching for, respectively, if the exact element cannot be found.\n\t   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t   *\n\t   * and an object is returned with the following properties:\n\t   *\n\t   *   - source: The original source file, or null.\n\t   *   - line: The line number in the original source, or null.\n\t   *   - column: The column number in the original source, or null.\n\t   *   - name: The original identifier, or null.\n\t   */\n\t  BasicSourceMapConsumer.prototype.originalPositionFor =\n\t    function SourceMapConsumer_originalPositionFor(aArgs) {\n\t      var needle = {\n\t        generatedLine: util.getArg(aArgs, 'line'),\n\t        generatedColumn: util.getArg(aArgs, 'column')\n\t      };\n\n\t      var index = this._findMapping(\n\t        needle,\n\t        this._generatedMappings,\n\t        \"generatedLine\",\n\t        \"generatedColumn\",\n\t        util.compareByGeneratedPositionsDeflated,\n\t        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t      );\n\n\t      if (index >= 0) {\n\t        var mapping = this._generatedMappings[index];\n\n\t        if (mapping.generatedLine === needle.generatedLine) {\n\t          var source = util.getArg(mapping, 'source', null);\n\t          if (source !== null) {\n\t            source = this._sources.at(source);\n\t            if (this.sourceRoot != null) {\n\t              source = util.join(this.sourceRoot, source);\n\t            }\n\t          }\n\t          var name = util.getArg(mapping, 'name', null);\n\t          if (name !== null) {\n\t            name = this._names.at(name);\n\t          }\n\t          return {\n\t            source: source,\n\t            line: util.getArg(mapping, 'originalLine', null),\n\t            column: util.getArg(mapping, 'originalColumn', null),\n\t            name: name\n\t          };\n\t        }\n\t      }\n\n\t      return {\n\t        source: null,\n\t        line: null,\n\t        column: null,\n\t        name: null\n\t      };\n\t    };\n\n\t  /**\n\t   * Return true if we have the source content for every source in the source\n\t   * map, false otherwise.\n\t   */\n\t  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t    function BasicSourceMapConsumer_hasContentsOfAllSources() {\n\t      if (!this.sourcesContent) {\n\t        return false;\n\t      }\n\t      return this.sourcesContent.length >= this._sources.size() &&\n\t        !this.sourcesContent.some(function (sc) { return sc == null; });\n\t    };\n\n\t  /**\n\t   * Returns the original source content. The only argument is the url of the\n\t   * original source file. Returns null if no original source content is\n\t   * availible.\n\t   */\n\t  BasicSourceMapConsumer.prototype.sourceContentFor =\n\t    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t      if (!this.sourcesContent) {\n\t        return null;\n\t      }\n\n\t      if (this.sourceRoot != null) {\n\t        aSource = util.relative(this.sourceRoot, aSource);\n\t      }\n\n\t      if (this._sources.has(aSource)) {\n\t        return this.sourcesContent[this._sources.indexOf(aSource)];\n\t      }\n\n\t      var url;\n\t      if (this.sourceRoot != null\n\t          && (url = util.urlParse(this.sourceRoot))) {\n\t        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t        // many users. We can help them out when they expect file:// URIs to\n\t        // behave like it would if they were running a local HTTP server. See\n\t        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n\t        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t        if (url.scheme == \"file\"\n\t            && this._sources.has(fileUriAbsPath)) {\n\t          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t        }\n\n\t        if ((!url.path || url.path == \"/\")\n\t            && this._sources.has(\"/\" + aSource)) {\n\t          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n\t        }\n\t      }\n\n\t      // This function is used recursively from\n\t      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n\t      // don't want to throw if we can't find the source - we just want to\n\t      // return null, so we provide a flag to exit gracefully.\n\t      if (nullOnMissing) {\n\t        return null;\n\t      }\n\t      else {\n\t        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t      }\n\t    };\n\n\t  /**\n\t   * Returns the generated line and column information for the original source,\n\t   * line, and column positions provided. The only argument is an object with\n\t   * the following properties:\n\t   *\n\t   *   - source: The filename of the original source.\n\t   *   - line: The line number in the original source.\n\t   *   - column: The column number in the original source.\n\t   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t   *     closest element that is smaller than or greater than the one we are\n\t   *     searching for, respectively, if the exact element cannot be found.\n\t   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t   *\n\t   * and an object is returned with the following properties:\n\t   *\n\t   *   - line: The line number in the generated source, or null.\n\t   *   - column: The column number in the generated source, or null.\n\t   */\n\t  BasicSourceMapConsumer.prototype.generatedPositionFor =\n\t    function SourceMapConsumer_generatedPositionFor(aArgs) {\n\t      var source = util.getArg(aArgs, 'source');\n\t      if (this.sourceRoot != null) {\n\t        source = util.relative(this.sourceRoot, source);\n\t      }\n\t      if (!this._sources.has(source)) {\n\t        return {\n\t          line: null,\n\t          column: null,\n\t          lastColumn: null\n\t        };\n\t      }\n\t      source = this._sources.indexOf(source);\n\n\t      var needle = {\n\t        source: source,\n\t        originalLine: util.getArg(aArgs, 'line'),\n\t        originalColumn: util.getArg(aArgs, 'column')\n\t      };\n\n\t      var index = this._findMapping(\n\t        needle,\n\t        this._originalMappings,\n\t        \"originalLine\",\n\t        \"originalColumn\",\n\t        util.compareByOriginalPositions,\n\t        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t      );\n\n\t      if (index >= 0) {\n\t        var mapping = this._originalMappings[index];\n\n\t        if (mapping.source === needle.source) {\n\t          return {\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          };\n\t        }\n\t      }\n\n\t      return {\n\t        line: null,\n\t        column: null,\n\t        lastColumn: null\n\t      };\n\t    };\n\n\t  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n\t  /**\n\t   * An IndexedSourceMapConsumer instance represents a parsed source map which\n\t   * we can query for information. It differs from BasicSourceMapConsumer in\n\t   * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n\t   * input.\n\t   *\n\t   * The only parameter is a raw source map (either as a JSON string, or already\n\t   * parsed to an object). According to the spec for indexed source maps, they\n\t   * have the following attributes:\n\t   *\n\t   *   - version: Which version of the source map spec this map is following.\n\t   *   - file: Optional. The generated file this source map is associated with.\n\t   *   - sections: A list of section definitions.\n\t   *\n\t   * Each value under the \"sections\" field has two fields:\n\t   *   - offset: The offset into the original specified at which this section\n\t   *       begins to apply, defined as an object with a \"line\" and \"column\"\n\t   *       field.\n\t   *   - map: A source map definition. This source map could also be indexed,\n\t   *       but doesn't have to be.\n\t   *\n\t   * Instead of the \"map\" field, it's also possible to have a \"url\" field\n\t   * specifying a URL to retrieve a source map from, but that's currently\n\t   * unsupported.\n\t   *\n\t   * Here's an example source map, taken from the source map spec[0], but\n\t   * modified to omit a section which uses the \"url\" field.\n\t   *\n\t   *  {\n\t   *    version : 3,\n\t   *    file: \"app.js\",\n\t   *    sections: [{\n\t   *      offset: {line:100, column:10},\n\t   *      map: {\n\t   *        version : 3,\n\t   *        file: \"section.js\",\n\t   *        sources: [\"foo.js\", \"bar.js\"],\n\t   *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t   *        mappings: \"AAAA,E;;ABCDE;\"\n\t   *      }\n\t   *    }],\n\t   *  }\n\t   *\n\t   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n\t   */\n\t  function IndexedSourceMapConsumer(aSourceMap) {\n\t    var sourceMap = aSourceMap;\n\t    if (typeof aSourceMap === 'string') {\n\t      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t    }\n\n\t    var version = util.getArg(sourceMap, 'version');\n\t    var sections = util.getArg(sourceMap, 'sections');\n\n\t    if (version != this._version) {\n\t      throw new Error('Unsupported version: ' + version);\n\t    }\n\n\t    this._sources = new ArraySet();\n\t    this._names = new ArraySet();\n\n\t    var lastOffset = {\n\t      line: -1,\n\t      column: 0\n\t    };\n\t    this._sections = sections.map(function (s) {\n\t      if (s.url) {\n\t        // The url field will require support for asynchronicity.\n\t        // See https://github.com/mozilla/source-map/issues/16\n\t        throw new Error('Support for url field in sections not implemented.');\n\t      }\n\t      var offset = util.getArg(s, 'offset');\n\t      var offsetLine = util.getArg(offset, 'line');\n\t      var offsetColumn = util.getArg(offset, 'column');\n\n\t      if (offsetLine < lastOffset.line ||\n\t          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n\t        throw new Error('Section offsets must be ordered and non-overlapping.');\n\t      }\n\t      lastOffset = offset;\n\n\t      return {\n\t        generatedOffset: {\n\t          // The offset fields are 0-based, but we use 1-based indices when\n\t          // encoding/decoding from VLQ.\n\t          generatedLine: offsetLine + 1,\n\t          generatedColumn: offsetColumn + 1\n\t        },\n\t        consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n\t      }\n\t    });\n\t  }\n\n\t  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\t  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n\t  /**\n\t   * The version of the source mapping spec that we are consuming.\n\t   */\n\t  IndexedSourceMapConsumer.prototype._version = 3;\n\n\t  /**\n\t   * The list of original sources.\n\t   */\n\t  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n\t    get: function () {\n\t      var sources = [];\n\t      for (var i = 0; i < this._sections.length; i++) {\n\t        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n\t          sources.push(this._sections[i].consumer.sources[j]);\n\t        }\n\t      }\n\t      return sources;\n\t    }\n\t  });\n\n\t  /**\n\t   * Returns the original source, line, and column information for the generated\n\t   * source's line and column positions provided. The only argument is an object\n\t   * with the following properties:\n\t   *\n\t   *   - line: The line number in the generated source.\n\t   *   - column: The column number in the generated source.\n\t   *\n\t   * and an object is returned with the following properties:\n\t   *\n\t   *   - source: The original source file, or null.\n\t   *   - line: The line number in the original source, or null.\n\t   *   - column: The column number in the original source, or null.\n\t   *   - name: The original identifier, or null.\n\t   */\n\t  IndexedSourceMapConsumer.prototype.originalPositionFor =\n\t    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n\t      var needle = {\n\t        generatedLine: util.getArg(aArgs, 'line'),\n\t        generatedColumn: util.getArg(aArgs, 'column')\n\t      };\n\n\t      // Find the section containing the generated position we're trying to map\n\t      // to an original position.\n\t      var sectionIndex = binarySearch.search(needle, this._sections,\n\t        function(needle, section) {\n\t          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\t          if (cmp) {\n\t            return cmp;\n\t          }\n\n\t          return (needle.generatedColumn -\n\t                  section.generatedOffset.generatedColumn);\n\t        });\n\t      var section = this._sections[sectionIndex];\n\n\t      if (!section) {\n\t        return {\n\t          source: null,\n\t          line: null,\n\t          column: null,\n\t          name: null\n\t        };\n\t      }\n\n\t      return section.consumer.originalPositionFor({\n\t        line: needle.generatedLine -\n\t          (section.generatedOffset.generatedLine - 1),\n\t        column: needle.generatedColumn -\n\t          (section.generatedOffset.generatedLine === needle.generatedLine\n\t           ? section.generatedOffset.generatedColumn - 1\n\t           : 0),\n\t        bias: aArgs.bias\n\t      });\n\t    };\n\n\t  /**\n\t   * Return true if we have the source content for every source in the source\n\t   * map, false otherwise.\n\t   */\n\t  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t    function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n\t      return this._sections.every(function (s) {\n\t        return s.consumer.hasContentsOfAllSources();\n\t      });\n\t    };\n\n\t  /**\n\t   * Returns the original source content. The only argument is the url of the\n\t   * original source file. Returns null if no original source content is\n\t   * available.\n\t   */\n\t  IndexedSourceMapConsumer.prototype.sourceContentFor =\n\t    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t      for (var i = 0; i < this._sections.length; i++) {\n\t        var section = this._sections[i];\n\n\t        var content = section.consumer.sourceContentFor(aSource, true);\n\t        if (content) {\n\t          return content;\n\t        }\n\t      }\n\t      if (nullOnMissing) {\n\t        return null;\n\t      }\n\t      else {\n\t        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t      }\n\t    };\n\n\t  /**\n\t   * Returns the generated line and column information for the original source,\n\t   * line, and column positions provided. The only argument is an object with\n\t   * the following properties:\n\t   *\n\t   *   - source: The filename of the original source.\n\t   *   - line: The line number in the original source.\n\t   *   - column: The column number in the original source.\n\t   *\n\t   * and an object is returned with the following properties:\n\t   *\n\t   *   - line: The line number in the generated source, or null.\n\t   *   - column: The column number in the generated source, or null.\n\t   */\n\t  IndexedSourceMapConsumer.prototype.generatedPositionFor =\n\t    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n\t      for (var i = 0; i < this._sections.length; i++) {\n\t        var section = this._sections[i];\n\n\t        // Only consider this section if the requested source is in the list of\n\t        // sources of the consumer.\n\t        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n\t          continue;\n\t        }\n\t        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\t        if (generatedPosition) {\n\t          var ret = {\n\t            line: generatedPosition.line +\n\t              (section.generatedOffset.generatedLine - 1),\n\t            column: generatedPosition.column +\n\t              (section.generatedOffset.generatedLine === generatedPosition.line\n\t               ? section.generatedOffset.generatedColumn - 1\n\t               : 0)\n\t          };\n\t          return ret;\n\t        }\n\t      }\n\n\t      return {\n\t        line: null,\n\t        column: null\n\t      };\n\t    };\n\n\t  /**\n\t   * Parse the mappings in a string in to a data structure which we can easily\n\t   * query (the ordered arrays in the `this.__generatedMappings` and\n\t   * `this.__originalMappings` properties).\n\t   */\n\t  IndexedSourceMapConsumer.prototype._parseMappings =\n\t    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t      this.__generatedMappings = [];\n\t      this.__originalMappings = [];\n\t      for (var i = 0; i < this._sections.length; i++) {\n\t        var section = this._sections[i];\n\t        var sectionMappings = section.consumer._generatedMappings;\n\t        for (var j = 0; j < sectionMappings.length; j++) {\n\t          var mapping = sectionMappings[i];\n\n\t          var source = section.consumer._sources.at(mapping.source);\n\t          if (section.consumer.sourceRoot !== null) {\n\t            source = util.join(section.consumer.sourceRoot, source);\n\t          }\n\t          this._sources.add(source);\n\t          source = this._sources.indexOf(source);\n\n\t          var name = section.consumer._names.at(mapping.name);\n\t          this._names.add(name);\n\t          name = this._names.indexOf(name);\n\n\t          // The mappings coming from the consumer for the section have\n\t          // generated positions relative to the start of the section, so we\n\t          // need to offset them to be relative to the start of the concatenated\n\t          // generated file.\n\t          var adjustedMapping = {\n\t            source: source,\n\t            generatedLine: mapping.generatedLine +\n\t              (section.generatedOffset.generatedLine - 1),\n\t            generatedColumn: mapping.column +\n\t              (section.generatedOffset.generatedLine === mapping.generatedLine)\n\t              ? section.generatedOffset.generatedColumn - 1\n\t              : 0,\n\t            originalLine: mapping.originalLine,\n\t            originalColumn: mapping.originalColumn,\n\t            name: name\n\t          };\n\n\t          this.__generatedMappings.push(adjustedMapping);\n\t          if (typeof adjustedMapping.originalLine === 'number') {\n\t            this.__originalMappings.push(adjustedMapping);\n\t          }\n\t        }\n\t      }\n\n\t      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t      quickSort(this.__originalMappings, util.compareByOriginalPositions);\n\t    };\n\n\t  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t{\n\t  /**\n\t   * This is a helper function for getting values from parameter/options\n\t   * objects.\n\t   *\n\t   * @param args The object we are extracting values from\n\t   * @param name The name of the property we are getting.\n\t   * @param defaultValue An optional value to return if the property is missing\n\t   * from the object. If this is not specified and the property is missing, an\n\t   * error will be thrown.\n\t   */\n\t  function getArg(aArgs, aName, aDefaultValue) {\n\t    if (aName in aArgs) {\n\t      return aArgs[aName];\n\t    } else if (arguments.length === 3) {\n\t      return aDefaultValue;\n\t    } else {\n\t      throw new Error('\"' + aName + '\" is a required argument.');\n\t    }\n\t  }\n\t  exports.getArg = getArg;\n\n\t  var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n\t  var dataUrlRegexp = /^data:.+\\,.+$/;\n\n\t  function urlParse(aUrl) {\n\t    var match = aUrl.match(urlRegexp);\n\t    if (!match) {\n\t      return null;\n\t    }\n\t    return {\n\t      scheme: match[1],\n\t      auth: match[2],\n\t      host: match[3],\n\t      port: match[4],\n\t      path: match[5]\n\t    };\n\t  }\n\t  exports.urlParse = urlParse;\n\n\t  function urlGenerate(aParsedUrl) {\n\t    var url = '';\n\t    if (aParsedUrl.scheme) {\n\t      url += aParsedUrl.scheme + ':';\n\t    }\n\t    url += '//';\n\t    if (aParsedUrl.auth) {\n\t      url += aParsedUrl.auth + '@';\n\t    }\n\t    if (aParsedUrl.host) {\n\t      url += aParsedUrl.host;\n\t    }\n\t    if (aParsedUrl.port) {\n\t      url += \":\" + aParsedUrl.port\n\t    }\n\t    if (aParsedUrl.path) {\n\t      url += aParsedUrl.path;\n\t    }\n\t    return url;\n\t  }\n\t  exports.urlGenerate = urlGenerate;\n\n\t  /**\n\t   * Normalizes a path, or the path portion of a URL:\n\t   *\n\t   * - Replaces consequtive slashes with one slash.\n\t   * - Removes unnecessary '.' parts.\n\t   * - Removes unnecessary '<dir>/..' parts.\n\t   *\n\t   * Based on code in the Node.js 'path' core module.\n\t   *\n\t   * @param aPath The path or url to normalize.\n\t   */\n\t  function normalize(aPath) {\n\t    var path = aPath;\n\t    var url = urlParse(aPath);\n\t    if (url) {\n\t      if (!url.path) {\n\t        return aPath;\n\t      }\n\t      path = url.path;\n\t    }\n\t    var isAbsolute = exports.isAbsolute(path);\n\n\t    var parts = path.split(/\\/+/);\n\t    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n\t      part = parts[i];\n\t      if (part === '.') {\n\t        parts.splice(i, 1);\n\t      } else if (part === '..') {\n\t        up++;\n\t      } else if (up > 0) {\n\t        if (part === '') {\n\t          // The first part is blank if the path is absolute. Trying to go\n\t          // above the root is a no-op. Therefore we can remove all '..' parts\n\t          // directly after the root.\n\t          parts.splice(i + 1, up);\n\t          up = 0;\n\t        } else {\n\t          parts.splice(i, 2);\n\t          up--;\n\t        }\n\t      }\n\t    }\n\t    path = parts.join('/');\n\n\t    if (path === '') {\n\t      path = isAbsolute ? '/' : '.';\n\t    }\n\n\t    if (url) {\n\t      url.path = path;\n\t      return urlGenerate(url);\n\t    }\n\t    return path;\n\t  }\n\t  exports.normalize = normalize;\n\n\t  /**\n\t   * Joins two paths/URLs.\n\t   *\n\t   * @param aRoot The root path or URL.\n\t   * @param aPath The path or URL to be joined with the root.\n\t   *\n\t   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t   *   first.\n\t   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t   *   is updated with the result and aRoot is returned. Otherwise the result\n\t   *   is returned.\n\t   *   - If aPath is absolute, the result is aPath.\n\t   *   - Otherwise the two paths are joined with a slash.\n\t   * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t   */\n\t  function join(aRoot, aPath) {\n\t    if (aRoot === \"\") {\n\t      aRoot = \".\";\n\t    }\n\t    if (aPath === \"\") {\n\t      aPath = \".\";\n\t    }\n\t    var aPathUrl = urlParse(aPath);\n\t    var aRootUrl = urlParse(aRoot);\n\t    if (aRootUrl) {\n\t      aRoot = aRootUrl.path || '/';\n\t    }\n\n\t    // `join(foo, '//www.example.org')`\n\t    if (aPathUrl && !aPathUrl.scheme) {\n\t      if (aRootUrl) {\n\t        aPathUrl.scheme = aRootUrl.scheme;\n\t      }\n\t      return urlGenerate(aPathUrl);\n\t    }\n\n\t    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t      return aPath;\n\t    }\n\n\t    // `join('http://', 'www.example.com')`\n\t    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t      aRootUrl.host = aPath;\n\t      return urlGenerate(aRootUrl);\n\t    }\n\n\t    var joined = aPath.charAt(0) === '/'\n\t      ? aPath\n\t      : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n\t    if (aRootUrl) {\n\t      aRootUrl.path = joined;\n\t      return urlGenerate(aRootUrl);\n\t    }\n\t    return joined;\n\t  }\n\t  exports.join = join;\n\n\t  exports.isAbsolute = function (aPath) {\n\t    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n\t  };\n\n\t  /**\n\t   * Make a path relative to a URL or another path.\n\t   *\n\t   * @param aRoot The root path or URL.\n\t   * @param aPath The path or URL to be made relative to aRoot.\n\t   */\n\t  function relative(aRoot, aPath) {\n\t    if (aRoot === \"\") {\n\t      aRoot = \".\";\n\t    }\n\n\t    aRoot = aRoot.replace(/\\/$/, '');\n\n\t    // It is possible for the path to be above the root. In this case, simply\n\t    // checking whether the root is a prefix of the path won't work. Instead, we\n\t    // need to remove components from the root one by one, until either we find\n\t    // a prefix that fits, or we run out of components to remove.\n\t    var level = 0;\n\t    while (aPath.indexOf(aRoot + '/') !== 0) {\n\t      var index = aRoot.lastIndexOf(\"/\");\n\t      if (index < 0) {\n\t        return aPath;\n\t      }\n\n\t      // If the only part of the root that is left is the scheme (i.e. http://,\n\t      // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t      // have exhausted all components, so the path is not relative to the root.\n\t      aRoot = aRoot.slice(0, index);\n\t      if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t        return aPath;\n\t      }\n\n\t      ++level;\n\t    }\n\n\t    // Make sure we add a \"../\" for each component we removed from the root.\n\t    return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t  }\n\t  exports.relative = relative;\n\n\t  /**\n\t   * Because behavior goes wacky when you set `__proto__` on objects, we\n\t   * have to prefix all the strings in our set with an arbitrary character.\n\t   *\n\t   * See https://github.com/mozilla/source-map/pull/31 and\n\t   * https://github.com/mozilla/source-map/issues/30\n\t   *\n\t   * @param String aStr\n\t   */\n\t  function toSetString(aStr) {\n\t    return '$' + aStr;\n\t  }\n\t  exports.toSetString = toSetString;\n\n\t  function fromSetString(aStr) {\n\t    return aStr.substr(1);\n\t  }\n\t  exports.fromSetString = fromSetString;\n\n\t  /**\n\t   * Comparator between two mappings where the original positions are compared.\n\t   *\n\t   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t   * mappings with the same original source/line/column, but different generated\n\t   * line and column the same. Useful when searching for a mapping with a\n\t   * stubbed out mapping.\n\t   */\n\t  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t    var cmp = mappingA.source - mappingB.source;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.originalLine - mappingB.originalLine;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t    if (cmp !== 0 || onlyCompareOriginal) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    return mappingA.name - mappingB.name;\n\t  }\n\t  exports.compareByOriginalPositions = compareByOriginalPositions;\n\n\t  /**\n\t   * Comparator between two mappings with deflated source and name indices where\n\t   * the generated positions are compared.\n\t   *\n\t   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t   * mappings with the same generated line and column, but different\n\t   * source/name/original line and column the same. Useful when searching for a\n\t   * mapping with a stubbed out mapping.\n\t   */\n\t  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t    if (cmp !== 0 || onlyCompareGenerated) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.source - mappingB.source;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.originalLine - mappingB.originalLine;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    return mappingA.name - mappingB.name;\n\t  }\n\t  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n\t  function strcmp(aStr1, aStr2) {\n\t    if (aStr1 === aStr2) {\n\t      return 0;\n\t    }\n\n\t    if (aStr1 > aStr2) {\n\t      return 1;\n\t    }\n\n\t    return -1;\n\t  }\n\n\t  /**\n\t   * Comparator between two mappings with inflated source and name strings where\n\t   * the generated positions are compared.\n\t   */\n\t  function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = strcmp(mappingA.source, mappingB.source);\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.originalLine - mappingB.originalLine;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t    if (cmp !== 0) {\n\t      return cmp;\n\t    }\n\n\t    return strcmp(mappingA.name, mappingB.name);\n\t  }\n\t  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\t}\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t{\n\t  exports.GREATEST_LOWER_BOUND = 1;\n\t  exports.LEAST_UPPER_BOUND = 2;\n\n\t  /**\n\t   * Recursive implementation of binary search.\n\t   *\n\t   * @param aLow Indices here and lower do not contain the needle.\n\t   * @param aHigh Indices here and higher do not contain the needle.\n\t   * @param aNeedle The element being searched for.\n\t   * @param aHaystack The non-empty array being searched.\n\t   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t   *     closest element that is smaller than or greater than the one we are\n\t   *     searching for, respectively, if the exact element cannot be found.\n\t   */\n\t  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n\t    // This function terminates when one of the following is true:\n\t    //\n\t    //   1. We find the exact element we are looking for.\n\t    //\n\t    //   2. We did not find the exact element, but we can return the index of\n\t    //      the next-closest element.\n\t    //\n\t    //   3. We did not find the exact element, and there is no next-closest\n\t    //      element than the one we are searching for, so we return -1.\n\t    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n\t    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\t    if (cmp === 0) {\n\t      // Found the element we are looking for.\n\t      return mid;\n\t    }\n\t    else if (cmp > 0) {\n\t      // Our needle is greater than aHaystack[mid].\n\t      if (aHigh - mid > 1) {\n\t        // The element is in the upper half.\n\t        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n\t      }\n\n\t      // The exact needle element was not found in this haystack. Determine if\n\t      // we are in termination case (3) or (2) and return the appropriate thing.\n\t      if (aBias == exports.LEAST_UPPER_BOUND) {\n\t        return aHigh < aHaystack.length ? aHigh : -1;\n\t      } else {\n\t        return mid;\n\t      }\n\t    }\n\t    else {\n\t      // Our needle is less than aHaystack[mid].\n\t      if (mid - aLow > 1) {\n\t        // The element is in the lower half.\n\t        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n\t      }\n\n\t      // we are in termination case (3) or (2) and return the appropriate thing.\n\t      if (aBias == exports.LEAST_UPPER_BOUND) {\n\t        return mid;\n\t      } else {\n\t        return aLow < 0 ? -1 : aLow;\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * This is an implementation of binary search which will always try and return\n\t   * the index of the closest element if there is no exact hit. This is because\n\t   * mappings between original and generated line/col pairs are single points,\n\t   * and there is an implicit region between each of them, so a miss just means\n\t   * that you aren't on the very start of a region.\n\t   *\n\t   * @param aNeedle The element you are looking for.\n\t   * @param aHaystack The array that is being searched.\n\t   * @param aCompare A function which takes the needle and an element in the\n\t   *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t   *     than, equal to, or greater than the element, respectively.\n\t   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t   *     closest element that is smaller than or greater than the one we are\n\t   *     searching for, respectively, if the exact element cannot be found.\n\t   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t   */\n\t  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n\t    if (aHaystack.length === 0) {\n\t      return -1;\n\t    }\n\n\t    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n\t                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\t    if (index < 0) {\n\t      return -1;\n\t    }\n\n\t    // We have found either the exact element, or the next-closest element than\n\t    // the one we are searching for. However, there may be more than one such\n\t    // element. Make sure we always return the smallest of these.\n\t    while (index - 1 >= 0) {\n\t      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n\t        break;\n\t      }\n\t      --index;\n\t    }\n\n\t    return index;\n\t  };\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t{\n\t  var util = __webpack_require__(1);\n\n\t  /**\n\t   * A data structure which is a combination of an array and a set. Adding a new\n\t   * member is O(1), testing for membership is O(1), and finding the index of an\n\t   * element is O(1). Removing elements from the set is not supported. Only\n\t   * strings are supported for membership.\n\t   */\n\t  function ArraySet() {\n\t    this._array = [];\n\t    this._set = {};\n\t  }\n\n\t  /**\n\t   * Static method for creating ArraySet instances from an existing array.\n\t   */\n\t  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t    var set = new ArraySet();\n\t    for (var i = 0, len = aArray.length; i < len; i++) {\n\t      set.add(aArray[i], aAllowDuplicates);\n\t    }\n\t    return set;\n\t  };\n\n\t  /**\n\t   * Return how many unique items are in this ArraySet. If duplicates have been\n\t   * added, than those do not count towards the size.\n\t   *\n\t   * @returns Number\n\t   */\n\t  ArraySet.prototype.size = function ArraySet_size() {\n\t    return Object.getOwnPropertyNames(this._set).length;\n\t  };\n\n\t  /**\n\t   * Add the given string to this set.\n\t   *\n\t   * @param String aStr\n\t   */\n\t  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t    var sStr = util.toSetString(aStr);\n\t    var isDuplicate = this._set.hasOwnProperty(sStr);\n\t    var idx = this._array.length;\n\t    if (!isDuplicate || aAllowDuplicates) {\n\t      this._array.push(aStr);\n\t    }\n\t    if (!isDuplicate) {\n\t      this._set[sStr] = idx;\n\t    }\n\t  };\n\n\t  /**\n\t   * Is the given string a member of this set?\n\t   *\n\t   * @param String aStr\n\t   */\n\t  ArraySet.prototype.has = function ArraySet_has(aStr) {\n\t    var sStr = util.toSetString(aStr);\n\t    return this._set.hasOwnProperty(sStr);\n\t  };\n\n\t  /**\n\t   * What is the index of the given string in the array?\n\t   *\n\t   * @param String aStr\n\t   */\n\t  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t    var sStr = util.toSetString(aStr);\n\t    if (this._set.hasOwnProperty(sStr)) {\n\t      return this._set[sStr];\n\t    }\n\t    throw new Error('\"' + aStr + '\" is not in the set.');\n\t  };\n\n\t  /**\n\t   * What is the element at the given index?\n\t   *\n\t   * @param Number aIdx\n\t   */\n\t  ArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t    if (aIdx >= 0 && aIdx < this._array.length) {\n\t      return this._array[aIdx];\n\t    }\n\t    throw new Error('No element indexed by ' + aIdx);\n\t  };\n\n\t  /**\n\t   * Returns the array representation of this set (which has the proper indices\n\t   * indicated by indexOf). Note that this is a copy of the internal array used\n\t   * for storing the members so that no one can mess with internal state.\n\t   */\n\t  ArraySet.prototype.toArray = function ArraySet_toArray() {\n\t    return this._array.slice();\n\t  };\n\n\t  exports.ArraySet = ArraySet;\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t *\n\t * Based on the Base 64 VLQ implementation in Closure Compiler:\n\t * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n\t *\n\t * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *  * Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t *  * Redistributions in binary form must reproduce the above\n\t *    copyright notice, this list of conditions and the following\n\t *    disclaimer in the documentation and/or other materials provided\n\t *    with the distribution.\n\t *  * Neither the name of Google Inc. nor the names of its\n\t *    contributors may be used to endorse or promote products derived\n\t *    from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t{\n\t  var base64 = __webpack_require__(5);\n\n\t  // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n\t  // length quantities we use in the source map spec, the first bit is the sign,\n\t  // the next four bits are the actual value, and the 6th bit is the\n\t  // continuation bit. The continuation bit tells us whether there are more\n\t  // digits in this value following this digit.\n\t  //\n\t  //   Continuation\n\t  //   |    Sign\n\t  //   |    |\n\t  //   V    V\n\t  //   101011\n\n\t  var VLQ_BASE_SHIFT = 5;\n\n\t  // binary: 100000\n\t  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n\t  // binary: 011111\n\t  var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n\t  // binary: 100000\n\t  var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n\t  /**\n\t   * Converts from a two-complement value to a value where the sign bit is\n\t   * placed in the least significant bit.  For example, as decimals:\n\t   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n\t   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n\t   */\n\t  function toVLQSigned(aValue) {\n\t    return aValue < 0\n\t      ? ((-aValue) << 1) + 1\n\t      : (aValue << 1) + 0;\n\t  }\n\n\t  /**\n\t   * Converts to a two-complement value from a value where the sign bit is\n\t   * placed in the least significant bit.  For example, as decimals:\n\t   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n\t   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n\t   */\n\t  function fromVLQSigned(aValue) {\n\t    var isNegative = (aValue & 1) === 1;\n\t    var shifted = aValue >> 1;\n\t    return isNegative\n\t      ? -shifted\n\t      : shifted;\n\t  }\n\n\t  /**\n\t   * Returns the base 64 VLQ encoded value.\n\t   */\n\t  exports.encode = function base64VLQ_encode(aValue) {\n\t    var encoded = \"\";\n\t    var digit;\n\n\t    var vlq = toVLQSigned(aValue);\n\n\t    do {\n\t      digit = vlq & VLQ_BASE_MASK;\n\t      vlq >>>= VLQ_BASE_SHIFT;\n\t      if (vlq > 0) {\n\t        // There are still more digits in this value, so we must make sure the\n\t        // continuation bit is marked.\n\t        digit |= VLQ_CONTINUATION_BIT;\n\t      }\n\t      encoded += base64.encode(digit);\n\t    } while (vlq > 0);\n\n\t    return encoded;\n\t  };\n\n\t  /**\n\t   * Decodes the next base 64 VLQ value from the given string and returns the\n\t   * value and the rest of the string via the out parameter.\n\t   */\n\t  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n\t    var strLen = aStr.length;\n\t    var result = 0;\n\t    var shift = 0;\n\t    var continuation, digit;\n\n\t    do {\n\t      if (aIndex >= strLen) {\n\t        throw new Error(\"Expected more digits in base 64 VLQ value.\");\n\t      }\n\n\t      digit = base64.decode(aStr.charCodeAt(aIndex++));\n\t      if (digit === -1) {\n\t        throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n\t      }\n\n\t      continuation = !!(digit & VLQ_CONTINUATION_BIT);\n\t      digit &= VLQ_BASE_MASK;\n\t      result = result + (digit << shift);\n\t      shift += VLQ_BASE_SHIFT;\n\t    } while (continuation);\n\n\t    aOutParam.value = fromVLQSigned(result);\n\t    aOutParam.rest = aIndex;\n\t  };\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t{\n\t  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n\t  /**\n\t   * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n\t   */\n\t  exports.encode = function (number) {\n\t    if (0 <= number && number < intToCharMap.length) {\n\t      return intToCharMap[number];\n\t    }\n\t    throw new TypeError(\"Must be between 0 and 63: \" + number);\n\t  };\n\n\t  /**\n\t   * Decode a single base 64 character code digit to an integer. Returns -1 on\n\t   * failure.\n\t   */\n\t  exports.decode = function (charCode) {\n\t    var bigA = 65;     // 'A'\n\t    var bigZ = 90;     // 'Z'\n\n\t    var littleA = 97;  // 'a'\n\t    var littleZ = 122; // 'z'\n\n\t    var zero = 48;     // '0'\n\t    var nine = 57;     // '9'\n\n\t    var plus = 43;     // '+'\n\t    var slash = 47;    // '/'\n\n\t    var littleOffset = 26;\n\t    var numberOffset = 52;\n\n\t    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t    if (bigA <= charCode && charCode <= bigZ) {\n\t      return (charCode - bigA);\n\t    }\n\n\t    // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\t    if (littleA <= charCode && charCode <= littleZ) {\n\t      return (charCode - littleA + littleOffset);\n\t    }\n\n\t    // 52 - 61: 0123456789\n\t    if (zero <= charCode && charCode <= nine) {\n\t      return (charCode - zero + numberOffset);\n\t    }\n\n\t    // 62: +\n\t    if (charCode == plus) {\n\t      return 62;\n\t    }\n\n\t    // 63: /\n\t    if (charCode == slash) {\n\t      return 63;\n\t    }\n\n\t    // Invalid base64 digit.\n\t    return -1;\n\t  };\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t{\n\t  // It turns out that some (most?) JavaScript engines don't self-host\n\t  // `Array.prototype.sort`. This makes sense because C++ will likely remain\n\t  // faster than JS when doing raw CPU-intensive sorting. However, when using a\n\t  // custom comparator function, calling back and forth between the VM's C++ and\n\t  // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n\t  // worse generated code for the comparator function than would be optimal. In\n\t  // fact, when sorting with a comparator, these costs outweigh the benefits of\n\t  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n\t  // a ~3500ms mean speed-up in `bench/bench.html`.\n\n\t  /**\n\t   * Swap the elements indexed by `x` and `y` in the array `ary`.\n\t   *\n\t   * @param {Array} ary\n\t   *        The array.\n\t   * @param {Number} x\n\t   *        The index of the first item.\n\t   * @param {Number} y\n\t   *        The index of the second item.\n\t   */\n\t  function swap(ary, x, y) {\n\t    var temp = ary[x];\n\t    ary[x] = ary[y];\n\t    ary[y] = temp;\n\t  }\n\n\t  /**\n\t   * Returns a random integer within the range `low .. high` inclusive.\n\t   *\n\t   * @param {Number} low\n\t   *        The lower bound on the range.\n\t   * @param {Number} high\n\t   *        The upper bound on the range.\n\t   */\n\t  function randomIntInRange(low, high) {\n\t    return Math.round(low + (Math.random() * (high - low)));\n\t  }\n\n\t  /**\n\t   * The Quick Sort algorithm.\n\t   *\n\t   * @param {Array} ary\n\t   *        An array to sort.\n\t   * @param {function} comparator\n\t   *        Function to use to compare two items.\n\t   * @param {Number} p\n\t   *        Start index of the array\n\t   * @param {Number} r\n\t   *        End index of the array\n\t   */\n\t  function doQuickSort(ary, comparator, p, r) {\n\t    // If our lower bound is less than our upper bound, we (1) partition the\n\t    // array into two pieces and (2) recurse on each half. If it is not, this is\n\t    // the empty array and our base case.\n\n\t    if (p < r) {\n\t      // (1) Partitioning.\n\t      //\n\t      // The partitioning chooses a pivot between `p` and `r` and moves all\n\t      // elements that are less than or equal to the pivot to the before it, and\n\t      // all the elements that are greater than it after it. The effect is that\n\t      // once partition is done, the pivot is in the exact place it will be when\n\t      // the array is put in sorted order, and it will not need to be moved\n\t      // again. This runs in O(n) time.\n\n\t      // Always choose a random pivot so that an input array which is reverse\n\t      // sorted does not cause O(n^2) running time.\n\t      var pivotIndex = randomIntInRange(p, r);\n\t      var i = p - 1;\n\n\t      swap(ary, pivotIndex, r);\n\t      var pivot = ary[r];\n\n\t      // Immediately after `j` is incremented in this loop, the following hold\n\t      // true:\n\t      //\n\t      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n\t      //\n\t      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\t      for (var j = p; j < r; j++) {\n\t        if (comparator(ary[j], pivot) <= 0) {\n\t          i += 1;\n\t          swap(ary, i, j);\n\t        }\n\t      }\n\n\t      swap(ary, i + 1, j);\n\t      var q = i + 1;\n\n\t      // (2) Recurse on each half.\n\n\t      doQuickSort(ary, comparator, p, q - 1);\n\t      doQuickSort(ary, comparator, q + 1, r);\n\t    }\n\t  }\n\n\t  /**\n\t   * Sort the given array in-place with the given comparator function.\n\t   *\n\t   * @param {Array} ary\n\t   *        An array to sort.\n\t   * @param {function} comparator\n\t   *        Function to use to compare two items.\n\t   */\n\t  exports.quickSort = function (ary, comparator) {\n\t    doQuickSort(ary, comparator, 0, ary.length - 1);\n\t  };\n\t}\n\n\n/***/ }\n/******/ ]);","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap, root.StackFrame);\n    }\n}(this, function (SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param url [String]\n     * @return Promise with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function (resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if (req.status >= 200 && req.status < 300) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    function _findFunctionName(source, lineNumber, columnNumber) {\n        // function {name}({args}) m[1]=name m[2]=args\n        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n        // {name} = function ({args}) TODO args capture\n        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n        // {name} = eval()\n        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '', line, maxLines = Math.min(lineNumber, 20), m, commentPos;\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            line = lines[lineNumber - i - 1];\n            commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                m = reFunctionExpression.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionDeclaration.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionEvaluation.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' || stackframe.lineNumber % 1 !== 0 || stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' || stackframe.columnNumber % 1 !== 0 || stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n        if (m && m[1]) {\n            return m[1];\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMap(rawSourceMap, args, lineNumber, columnNumber, sourceCache) {\n        var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n\n        var loc = mapConsumer.originalPositionFor({\n            line: lineNumber,\n            column: columnNumber\n        });\n\n        var mappedSource = mapConsumer.sourceContentFor(loc.source);\n        if (mappedSource) {\n            sourceCache[loc.source] = mappedSource;\n        }\n\n        return new StackFrame(loc.name, args, loc.source, loc.line, loc.column);\n    }\n\n    /**\n     * @param opts: [Object] options.\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n\n        this.ajax = _xdr;\n\n        this._get = function _get(location) {\n            return new Promise(function (resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        var supportedEncoding = 'application/json;base64';\n                        if (location.substr(5, supportedEncoding.length) !== supportedEncoding) {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        } else {\n                            var sourceMapStart = 'data:'.length + supportedEncoding.length + ','.length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = window.atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param stackframe - {StackFrame}-like object\n         *      {fileName: 'path/to/file.js', lineNumber: 100, columnNumber: 5}\n         * @return StackFrame with source-mapped location\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function (resolve, reject) {\n                this.getMappedLocation(stackframe).then(function (mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param stackframe - {StackFrame}-like object\n         *      {fileName: 'path/to/file.js', lineNumber: 100, columnNumber: 5}\n         * @return StackFrame with guessed function name\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function (resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var guessedFunctionName = _findFunctionName(source, stackframe.lineNumber, stackframe.columnNumber);\n                    resolve(new StackFrame(guessedFunctionName, stackframe.args, stackframe.fileName, stackframe.lineNumber, stackframe.columnNumber));\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param stackframe - {StackFrame}-like object\n         *      {fileName: 'path/to/file.js', lineNumber: 100, columnNumber: 5}\n         * @return StackFrame with source-mapped location\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function (resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function (source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl) {\n                        sourceMappingURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + sourceMappingURL;\n                    }\n\n                    this._get(sourceMappingURL).then(function (map) {\n                        var lineNumber = stackframe.lineNumber;\n                        var columnNumber = stackframe.columnNumber;\n                        resolve(_extractLocationInfoFromSourceMap(map, stackframe.args, lineNumber, columnNumber, sourceCache));\n                    }, reject)['catch'](reject);\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n"],"sourceRoot":"/source/"}